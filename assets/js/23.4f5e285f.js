(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{269:function(t,e,n){"use strict";n.r(e);var a=n(28),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"可视化埋点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#可视化埋点"}},[t._v("#")]),t._v(" 可视化埋点")]),t._v(" "),n("p",[t._v("框架式埋点、无痕埋点")]),t._v(" "),n("p",[t._v("通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，从而实现所谓的“无痕埋点”，代表方案是已经开源的Mixpanel")]),t._v(" "),n("p",[t._v("动态埋点\n实现方案：\n利用AccessibilityDelegate对每个view实例设置代理，监听控件点击事件。\n代表方案：\nGithub 上开源的 Mixpanel\n优点：\n无需手动埋点，通过可视化圈选，动态下发配置监听指定控件。\n缺点：\n不支持数据可回溯，采集不到Fragment页面数据，只支持API 14及以上，"),n("br"),t._v("\n同时该监听方式对app性能影响严重，每个控件都需要动态绑定，在界面变更时，需要重新刷新ViewTree，效率低下。")]),t._v(" "),n("h2",{attrs:{id:"mixpanel"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mixpanel"}},[t._v("#")]),t._v(" Mixpanel")])])}),[],!1,null,null,null);e.default=r.exports}}]);